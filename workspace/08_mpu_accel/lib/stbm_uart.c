/** charset=UTF-8 **/#include "stbm_uart.h"#include <string.h>// おいおいボード変えても汎用性を持たせたい部分#define USART2_PORT          GPIOA#define USART2_RCC           RCC_APB2Periph_GPIOA#define USART2_GPIO_RCC      RCC_APB1Periph_USART2#define USART2_TX_PIN        GPIO_Pin_2#define USART2_RX_PIN        GPIO_Pin_3#define USART2_BAUD          57600#define TX_POINTER_BUFFER 16int8_t *TxData[TX_POINTER_BUFFER];uint8_t index_tx_current = 0;	// 送信バッファの現在通信中の番号uint8_t index_tx_add = 0;		// 送信バッファの次に足す箱の番号void xbee_init(){	GPIO_InitTypeDef GPIO_InitStructure;		RCC_APB2PeriphClockCmd(USART2_RCC, ENABLE);	RCC_APB1PeriphClockCmd(USART2_GPIO_RCC , ENABLE);		/* Configure USART Tx as alternate function push-pull */	GPIO_InitStructure.GPIO_Pin = USART2_TX_PIN;	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	GPIO_Init(USART2_PORT, &GPIO_InitStructure);		/* Configure USART Rx as input floating */	GPIO_InitStructure.GPIO_Pin = USART2_RX_PIN;	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	GPIO_Init(USART2_PORT, &GPIO_InitStructure);		/* USART configuration ------------------------------------------------------*/	USART_InitTypeDef USART_InitStructure;	USART_InitStructure.USART_BaudRate = USART2_BAUD;	USART_InitStructure.USART_WordLength = USART_WordLength_8b;	USART_InitStructure.USART_StopBits = USART_StopBits_1;	USART_InitStructure.USART_Parity = USART_Parity_No ;	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	USART_Init(USART2, &USART_InitStructure);		// USART2 DMA TX Requestを有効化	USART_DMACmd(USART2, USART_DMAReq_Tx, ENABLE);		// USARTを有効化	USART_Cmd(USART2, ENABLE);}void xbee_send_string(const char String[]){	// アイドルフラグ初期化	uint8_t idle_flag = 0;		// バッファ無しならアイドルフラグ立てる	if (index_tx_current == index_tx_add){		idle_flag = 1;	}		// バッファが残り1つならウェイトする	if (index_tx_current == index_tx_add + 1 || ( index_tx_add == TX_POINTER_BUFFER - 1 && index_tx_current == 0) ){		while(index_tx_current == index_tx_add + 1 || ( index_tx_add == TX_POINTER_BUFFER - 1 && index_tx_current == 0)){}	}		// 文字列のアドレスをバッファに登録し、インデックスをインクリメント	TxData[index_tx_add++] = (int8_t *)String;		// インデックスが最後までいったら最初に戻す	if (index_tx_add == TX_POINTER_BUFFER){		index_tx_add = 0;	}		// DMA送信開始	if (idle_flag != 0){	//if (index_tx_add == index_tx_current + 1 || ( index_tx_current == TX_POINTER_BUFFER - 1 && index_tx_add == 0)){		xbee_dma_configuration((uint32_t)TxData[index_tx_current], strlen(TxData[index_tx_current]));				// USARTy DMA TX Channel有効化		DMA_Cmd(DMA1_Channel7, ENABLE);	}}void xbee_dma_configuration(uint32_t Memory_Address, uint16_t Buffer_Size){	DMA_InitTypeDef DMA_InitStructure;		/* DMA clock enable */	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		/* DMA channel for USART2 (DMA1_Channel7) Config */	DMA_DeInit(DMA1_Channel7);	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&USART2->DR;	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)Memory_Address;	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;	DMA_InitStructure.DMA_BufferSize = Buffer_Size;	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;	DMA_Init(DMA1_Channel7, &DMA_InitStructure);		/* Enable DMA1 Channel7 Transfer Complete interrupt */	DMA_ITConfig(DMA1_Channel7, DMA_IT_TC, ENABLE);}// 暫定でここで定義。// 他とバッティングする可能性有。void xbee_nvic_configuration(void){	NVIC_InitTypeDef NVIC_InitStructure;		/* Enable DMA1 channel7 IRQ Channel */	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQn;	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	NVIC_Init(&NVIC_InitStructure);}void DMA1_Channel7_IRQHandler(void){	/* Test on DMA1 Channel7 Transfer Complete interrupt */	if(DMA_GetITStatus(DMA1_IT_TC7)==SET){		/* Disable USARTy DMA TX Channel */		DMA_Cmd(DMA1_Channel7, DISABLE);				// move to next string		index_tx_current++;		// if pointer reached the end of pointer buffer, make it go to front		if (index_tx_current == TX_POINTER_BUFFER){			index_tx_current = 0;		}				// if pointer processing reaches to pointer the next message to be add		// stops generate interrupt and stop sending.		if (index_tx_current != index_tx_add){			xbee_dma_configuration((uint32_t)TxData[index_tx_current], strlen(TxData[index_tx_current]));			/* Enable USARTy DMA TX Channel */			DMA_Cmd(DMA1_Channel7, ENABLE);		}		DMA_ClearITPendingBit(DMA1_IT_TC7);	}}